"""
Phase 5: Policy Rules Versioning Service
Handles versioning, diff calculation, and rollback for policy rules.
"""

import json
import hashlib
import logging
from typing import Dict, Any, List, Optional, Tuple
from difflib import unified_diff

try:
    from deepdiff import DeepDiff
    HAS_DEEPDIFF = True
except ImportError:
    HAS_DEEPDIFF = False

from app.database import SessionLocal
from app.models.policy_rules_version import PolicyRulesVersion
from app.models.policy_rules_draft import PolicyRulesDraft, DraftStatus
from app.models.policy_template import PolicyTemplate

logger = logging.getLogger(__name__)


class PolicyRulesVersioningService:
    """
    Service for managing policy rules versions, diffs, and rollbacks.

    Handles:
    - Version creation with integrity hashing
    - Diff calculation between versions
    - Rollback to previous versions
    - Version history management
    """

    def __init__(self):
        pass

    def create_version(
        self,
        policy_template_id: str,
        policy_rules: Dict[str, Any],
        created_by_user_id: str,
        draft_id: Optional[str] = None,
        llm_model: Optional[str] = None,
        llm_prompt_hash: Optional[str] = None,
        name: Optional[str] = None,
        notes: Optional[str] = None,
        llm_generated: bool = True
    ) -> PolicyRulesVersion:
        """
        Create a new version of policy rules.

        Args:
            policy_template_id: Template ID
            policy_rules: The rules JSON
            created_by_user_id: User creating the version
            draft_id: Source draft ID (if applicable)
            llm_model: LLM model used (if applicable)
            llm_prompt_hash: Hash of prompt used
            name: Human-readable version name
            notes: Version notes/changelog
            llm_generated: Whether this version was generated by LLM

        Returns:
            Created PolicyRulesVersion object
        """
        db = SessionLocal()
        try:
            # Calculate next version number
            last_version = db.query(PolicyRulesVersion).filter(
                PolicyRulesVersion.policy_template_id == policy_template_id
            ).order_by(PolicyRulesVersion.rules_version.desc()).first()

            next_version = (last_version.rules_version + 1) if last_version else 1

            # Calculate rules hash for integrity
            rules_hash = self._calculate_rules_hash(policy_rules)

            # Calculate diff from previous version
            diff_from_previous = None
            if last_version:
                diff_from_previous = self._calculate_diff(last_version.policy_rules, policy_rules)

            # Create version record
            version = PolicyRulesVersion(
                policy_template_id=policy_template_id,
                rules_version=next_version,
                policy_rules=policy_rules,
                draft_id=draft_id,
                llm_model=llm_model,
                llm_prompt_hash=llm_prompt_hash,
                name=name,
                notes=notes,
                llm_generated=llm_generated,
                rules_hash=rules_hash,
                diff_from_previous=diff_from_previous,
                created_by_user_id=created_by_user_id
            )

            db.add(version)
            db.commit()
            db.refresh(version)

            logger.info(
                f"Created policy rules version {next_version} for template {policy_template_id} "
                f"by user {created_by_user_id}"
            )

            return version

        finally:
            db.close()

    def rollback_to_version(
        self,
        policy_template_id: str,
        target_version: int,
        rollback_by_user_id: str,
        notes: Optional[str] = None
    ) -> Tuple[PolicyRulesVersion, PolicyRulesVersion]:
        """
        Rollback to a previous version by creating a new version with the old rules.

        Args:
            policy_template_id: Template ID
            target_version: Version number to rollback to
            rollback_by_user_id: User performing the rollback
            notes: Optional notes about the rollback

        Returns:
            Tuple of (target_version, new_version_created)
        """
        db = SessionLocal()
        try:
            # Get the target version to rollback to
            target_version_obj = db.query(PolicyRulesVersion).filter(
                PolicyRulesVersion.policy_template_id == policy_template_id,
                PolicyRulesVersion.rules_version == target_version
            ).first()

            if not target_version_obj:
                raise ValueError(f"Version {target_version} not found for template {policy_template_id}")

            # Create new version with the old rules
            rollback_notes = f"Rollback to version {target_version}"
            if notes:
                rollback_notes += f": {notes}"

            new_version = self.create_version(
                policy_template_id=policy_template_id,
                policy_rules=target_version_obj.policy_rules,
                created_by_user_id=rollback_by_user_id,
                name=f"Rollback to v{target_version}",
                notes=rollback_notes,
                llm_generated=False  # Rollbacks are manual operations
            )

            # Update the policy template to use the rolled-back rules
            template = db.query(PolicyTemplate).filter(
                PolicyTemplate.id == policy_template_id
            ).first()

            if template:
                template.policy_rules = new_version.policy_rules
                template.published_at = new_version.created_at
                template.published_by_user_id = rollback_by_user_id
                db.commit()

                logger.info(
                    f"Rolled back template {policy_template_id} from version {new_version.rules_version - 1} "
                    f"to version {target_version} (new version {new_version.rules_version})"
                )

            return target_version_obj, new_version

        finally:
            db.close()

    def get_version_history(self, policy_template_id: str, limit: int = 50) -> List[Dict[str, Any]]:
        """
        Get version history for a policy template.

        Args:
            policy_template_id: Template ID
            limit: Maximum number of versions to return

        Returns:
            List of version information dictionaries
        """
        db = SessionLocal()
        try:
            versions = db.query(PolicyRulesVersion).filter(
                PolicyRulesVersion.policy_template_id == policy_template_id
            ).order_by(PolicyRulesVersion.rules_version.desc()).limit(limit).all()

            history = []
            for version in versions:
                history.append({
                    "version": version.rules_version,
                    "name": version.name,
                    "notes": version.notes,
                    "llm_generated": version.llm_generated,
                    "rules_hash": version.rules_hash,
                    "created_by": version.created_by_user_id,
                    "created_at": version.created_at.isoformat(),
                    "rule_count": sum(len(rules) for rules in version.policy_rules.values()) if version.policy_rules else 0,
                    "diff_available": version.diff_from_previous is not None
                })

            return history

        finally:
            db.close()

    def calculate_version_diff(
        self,
        version1: PolicyRulesVersion,
        version2: PolicyRulesVersion
    ) -> Dict[str, Any]:
        """
        Calculate detailed diff between two versions.

        Args:
            version1: First version
            version2: Second version

        Returns:
            Detailed diff information
        """
        # Use deepdiff for comprehensive JSON diff
        diff = DeepDiff(
            version1.policy_rules,
            version2.policy_rules,
            ignore_order=True,
            report_repetition=True
        )

        # Categorize changes
        changes = {
            "added_rules": [],
            "removed_rules": [],
            "modified_rules": [],
            "added_categories": [],
            "removed_categories": []
        }

        # Analyze the diff
        if 'dictionary_item_added' in diff:
            for path in diff['dictionary_item_added']:
                if 'rules' in path and 'Professionalism' in path:  # Category level
                    changes["added_categories"].append(path.split("'")[1])
                elif 'rules' in path and any(cat in path for cat in ['Professionalism', 'Empathy', 'Resolution']):
                    changes["added_rules"].append(path.split("'")[-2])

        if 'dictionary_item_removed' in diff:
            for path in diff['dictionary_item_removed']:
                if 'rules' in path and 'Professionalism' in path:  # Category level
                    changes["removed_categories"].append(path.split("'")[1])
                elif 'rules' in path and any(cat in path for cat in ['Professionalism', 'Empathy', 'Resolution']):
                    changes["removed_rules"].append(path.split("'")[-2])

        if 'values_changed' in diff:
            for path in diff['values_changed']:
                if 'rules' in path and any(cat in path for cat in ['Professionalism', 'Empathy', 'Resolution']):
                    rule_id = path.split("'")[-2]
                    changes["modified_rules"].append(rule_id)

        return {
            "summary": {
                "categories_added": len(changes["added_categories"]),
                "categories_removed": len(changes["removed_categories"]),
                "rules_added": len(changes["added_rules"]),
                "rules_removed": len(changes["removed_rules"]),
                "rules_modified": len(changes["modified_rules"])
            },
            "details": changes,
            "raw_diff": diff.to_dict() if hasattr(diff, 'to_dict') else str(diff)
        }

    def create_draft_from_version(
        self,
        policy_template_id: str,
        version_number: int,
        created_by_user_id: str,
        draft_name: Optional[str] = None,
        draft_description: Optional[str] = None
    ) -> PolicyRulesDraft:
        """
        Create a draft from an existing version for editing.

        Args:
            policy_template_id: Template ID
            version_number: Version to create draft from
            created_by_user_id: User creating the draft
            draft_name: Optional name for the draft
            draft_description: Optional description

        Returns:
            Created PolicyRulesDraft object
        """
        db = SessionLocal()
        try:
            # Get the version
            version = db.query(PolicyRulesVersion).filter(
                PolicyRulesVersion.policy_template_id == policy_template_id,
                PolicyRulesVersion.rules_version == version_number
            ).first()

            if not version:
                raise ValueError(f"Version {version_number} not found for template {policy_template_id}")

            # Create draft
            draft = PolicyRulesDraft(
                policy_template_id=policy_template_id,
                status=DraftStatus.ready_for_confirm,  # Ready since we have rules
                policy_text="",  # Not applicable for manual edits
                generated_rules=version.policy_rules,
                parent_version=version.rules_version,
                is_manual_edit=True,
                name=draft_name or f"Draft from v{version_number}",
                description=draft_description,
                created_by_user_id=created_by_user_id,
                last_edited_by_user_id=created_by_user_id
            )

            db.add(draft)
            db.commit()
            db.refresh(draft)

            logger.info(f"Created draft {draft.id} from version {version_number} of template {policy_template_id}")

            return draft

        finally:
            db.close()

    def _calculate_rules_hash(self, policy_rules: Dict[str, Any]) -> str:
        """Calculate SHA256 hash of rules JSON for integrity checking."""
        # Canonical JSON for consistent hashing
        canonical_json = json.dumps(policy_rules, sort_keys=True, separators=(',', ':'))
        return hashlib.sha256(canonical_json.encode('utf-8')).hexdigest()

    def _calculate_diff(self, old_rules: Dict[str, Any], new_rules: Dict[str, Any]) -> Dict[str, Any]:
        """Calculate diff between two rule sets."""
        if not HAS_DEEPDIFF:
            return {"error": "deepdiff not available for detailed diff calculation"}

        try:
            diff = DeepDiff(old_rules, new_rules, ignore_order=True)
            return diff.to_dict() if hasattr(diff, 'to_dict') else {"error": "Could not serialize diff"}
        except Exception as e:
            logger.warning(f"Could not calculate diff: {e}")
            return {"error": str(e)}
